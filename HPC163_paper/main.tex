%\tiny
%\scriptsize
%\footnotesize
%\small

%\documentclass[submit,techrep]{ipsj}
%\documentclass[submit,techrep,noauthor]{ipsj}
\documentclass[submit,techrep,noauthor]{ipsj}

%\usepackage[dvips]{graphicx}
\usepackage[dvipdfmx]{graphicx,hyperref}
\usepackage{latexsym}
\usepackage{color}
\definecolor{blue}{rgb}{0.00, 0.00, 1.00}
\usepackage{listings}
\usepackage{amsmath}
\lstset{
language={C},
%basicstyle={\ttfamily},
basicstyle={\footnotesize},
numbers=left,
stepnumber=1,
breaklines=true,
lineskip=-0.5mm,
%xleftmargin=2zw,
frame={tb}, 
showtabs=false,
%formfeed={\hfill},
}
\usepackage{cite}
%	\usepackage{comment}
%	\usepackage{caption}
\def\newblock{\hskip .11em plus .33em minus .07em}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\setcounter{巻数}{53}%vol53=2012
\setcounter{号数}{10}
\setcounter{page}{1}


\begin{document}

\title{PMlibを用いた計算性能測定と性能可視化手法}

\affiliate{AICS}{理化学研究所 計算科学研究機構}
\affiliate{Kyushu}{九州大学 情報基盤研究開発センター}

\author{三上 和徳}{Kazunori Mikami}{AICS}[kazunori.mikami@riken.jp]
\author{小野 謙二}{Kenji Ono}{Kyushu}

\begin{abstract}
オープンソースライブラリPMlib
を用いたアプリケーションの性能評価手法について報告する。
HPCシステムの仕様上の最大計算性能と
アプリケーション実行時に達成される実行性能との違いが頻繁に指摘される。
この違いを議論する場合には、演算器の並列性やメモリ階層における局所性確保などの
ハードウエアの動作特性を中心に評価する視点と、
アプリケーションがソースプログラムレベルで要求する数値計算上の計算量と
コンピュータシステムが実際に実行する命令に基づいた計算量との違いを
評価する視点の双方が必要である。

PMlibは数値計算上の計算量を明示的に測定する機能と、HWPCが記録する計算量を
測定する機能とを有し、両者の違いを定量的に評価することを可能とする。
またHWPC測定時には内部でPAPI低レベルAPIを利用し、
一般に選択と解釈が容易ではない各種ハードウエアイベント統計情報を
カテゴリ分けしてアプリ利用者が評価しやすい情報として選択出力する。

{ \color{blue}
出力情報としてはアプリ実行中に蓄積された統計情報を時間平均化した
標準レポートに加え、
経過時間軸に沿った動的な情報の出力も可能であり、
計算性能の時系列挙動を可視化するWebブラウザパッケージとの連携利用
が可能な構成となっている。（この部分は次回報告にまわす）
}

これらの異なる基準での計算量・計算性能を評価することによって、
アプリケーションのHPCシステムにおける実行性能発現を理解する
一助とすることが可能である。

本報告ではPMlibを用いたアプリの性能評価手法を説明し、Intel Xeonサーバ
および富士通FX100上での評価事例を紹介する。
\end{abstract}

\maketitle

%1
{ \color{blue}
最後に句読点の変換を行うこと。全角。ー＞全角．に、また全角、ー＞全角，に\\
}

\section{はじめに}
研究の目的

計算科学アプリケーションの開発および利用の各局面において、
利用するHPCシステム上で性能評価作業を実施することが頻繁に行われる。
これは主に、アプリケーションの性能特性を把握した後、ソフトウエア上の
最適化を実施して高速処理を実現するための可能性を探るために行われる。
このような性能評価作業が頻繁に実施される背景として、
HPCシステムの仕様上の最大性能とアプリケーションが実際に達成する実行性能との
差が、アプリの種類によっては非常に大きいことがある。

最大性能と実行性能との違いに関して
演算器の並列性やメモリおよびキャッシュ階層構成における局所性などの
ハードウエアの動作特性と関連づけられて
多くの研究が行われている。

一方、アプリケーションがソースプログラムレベルで要求する数値計算上の計算量と、
コンピュータシステムが実際に実行する命令を　HWPC（ハードウエア性能カウンタ）
で測定した計算量との間でもしばしば大きな乖離がある。
この事は性能評価において重要な問題点として考慮されなければならない。

{ \color{blue}
例えば除算計算などはコンピュータシステムが実際に実行する命令ベースでの
（HWPCによる見かけ上の）実行性能が非常に高く表示されるが、
数値計算上（ソースプログラムで計上した）の計算量に基づく性能は一般に低い。
}

PMlibは数値計算上の計算量を明示的に測定する機能と、HWPCが記録する計算量を
測定する機能とを有し、両者の違いを定量的に評価することを可能とする。
HWPC測定には内部でPAPI低レベルAPIを利用し、
一般に選択と解釈が容易ではない各種ハードウエアイベント統計情報を
カテゴリ分けしてアプリ利用者が評価しやすい情報として選択出力する。
出力情報としてはアプリ実行中に蓄積された統計情報を時間平均化した
標準レポートに加え、
経過時間軸に沿った動的な情報の出力も可能であり、
計算性能の時系列挙動を可視化するWebブラウザパッケージとの連携利用
が可能な構成となっている。

本報告ではまず計算科学的観点での計算量とシステム評価的観点での計算量との違い
についていくつかの評価事例を示す。
次に、計算量から計算性能を求める段階で、その性能を律速する
ハードウエアの動作特性を読み取るPMlibの機能について事例を示す。

{ \color{blue}
性能情報の可視化については、次の機会に報告を行う???\\

性能測定値を時刻歴測定して可視化することによって得られる、
性能挙動の理解に与える効果については、次の機会に報告を行うことにする。
以下のような分類で、その効果を紹介できればいい。
\begin{itemize}
%	\setlength{\itemindent}{-5mm}
\item 静的な統計情報の可視化 - TRAiLとの連携
	\begin{itemize}
	\item ジョブの経過時間で平均化された値
	\end{itemize}
\item 動的な性能挙動の可視化 - TRAiLとの連携
	\begin{itemize}
	\item ジョブの経過時刻に沿った過渡的な挙動
	\item プロセス毎の過渡的な挙動
	\item プロセス間の計算負荷バランスの挙動
	\end{itemize}
\end{itemize}
}




\section {計算量と性能評価}

\subsection {計算科学的観点での性能}
\label{subsection:scientific-perf}
計算量という用語を用いる場合、計算科学アプリケーションの開発者は、
Fortran言語やC++言語などで記述されたソースプログラム上で計上される
数値計算量すなわち演算回数の合計値を
アプリケーションの計算量として認識することが多い。
計算量\begin{math} OP \end{math}は以下の式で表わされる。
%	\begin{math}
%	\end{math}
%単純結合式
\begin{align*}
OP_{source} = \#add + \#sub + \#mult + \#div \\
	+ \#max + \#sqrt + ...
\end{align*}

計算性能はこの計算量を計算経過時間で割った値として定義される。
\begin{align*}
Perf_{source} = OP_{source} / Time	% \div はあまり見た目が良くない、、、
\end{align*}

ソースプログラムで記述される
平方根・三角関数といった数学関数ではそれぞれに計算の「重たさ」が異なる
ことは良く認識されているが、
四則演算や最小最大などの基本的な演算の「重たさ」も演算の種類によって
相当に異なることに注意しなければならない。
演算の「重たさ」を係数
\begin{math} c_{op} \end{math}
として考慮すると、計算量は以下の式で表すことができる。

% OP_{system}
\begin{align*}
OP_{weight} =
	c_{add}\times \#add + c_{sub}\times \#sub + c_{mult}\times \#mult \\
	+ c_{div}\times \#div + c_{max}\times \#max + c_{sqrt}\times \#sqrt + ...
\end{align*}

HPCアプリケーションにおいて
所与の計算を効果的に達成するために計算時間の短縮をめざす場合、
必要な計算量を削減するアルゴリズムを開発・採用するというアプローチ
が多いが、そのような場合の計算量とは主に上記した
計算科学的観点での評価が意図される。
このような計算科学的観点での計算性能を以降数値計算性能と呼ぶことにする。

HPCシステムの性能評価に長く利用されてきたLinpack（HPCC）が出力する
Gflops値も加算・乗算の「重たさ」を１として上記結合式を評価した
計算量から、計算性能を次式で求めている。
\begin{align*}
Gflops = N^{2} \times ( 2/3 * N + 3/2 ) \times 1.0^{-9} / Time 
\end{align*}



\subsection {システム評価的観点での性能}
\label{subsection:system-perf}

アプリケーションをHPCシステム上で実行する段階では、
ソースプログラムを言語コンパイラを通して生成した実行プログラムの
機械語命令列としてスケジューリング処理することになる。
ソースプログラムでは単純な計算式であっても、実際に実行されるのは
複数の命令列であり、命令の種類・量・命令に対応する計算量（演算数）は、
実行するHPCシステムのアーキテクチャおよびコンパイラなど
言語処理系ソフトウエアの最適化水準に依存する部分が大きい。

HPCシステムが実際に処理するこの計算量を経過時間で割った値が
システム評価的観点での計算性能として定義される。

この計算量を測定するためには、HPCシステムに通常装備されている
HWPC(Hardware Performance Counter)に記録されるイベントカウント数
を利用することが可能である。
適切なAPIによってHWPCに記録された情報へアクセスし、
実行された命令数を測定して計算量を求める。

例えば浮動小数点演算に属する計算量はHPWCで計上されたイベント数を基にして
以下の式により求められる。

{ \color{blue}
線形結合式\\
\begin{math}
OP_{hwpc} = ****************
\end{math}\\
... HWPCベースの計算式を構築
}
以下このように測定される計算量をHWPC計算量とよび、HWPC計算量を基準とした
計算性能をHWPC計算性能と呼ぶことにする。
いわゆるシステム性能に主眼がおかれた文脈で使用されることが多い。

HWPC測定性能が非常に高く表示されるにもかかわらず、
数値計算上の性能は非常に低いという状況は、
本節で述べた観点が違う事による計算量の定義の違い、
およびハードウエアの有効利用の状況、
の双方の影響を受けた結果であるといえる。


\section{PMlib}

\subsection {PMlibについて}

PMlibはアプリケーションの計算性能モニター用のクラスライブラリであり、
オープンソースソフトウエアとして公開されている。
\cite{PMlib1:webpage} \par
\cite{PMlib2:webpage} \par
{ \color{blue} \par
（citeはどちらのWebページの方が良いか？）
} \par
PMlibは前述した２種類の計算性能（数値計算性能とHWPC計算性能）
を測定する機能を持つ。
アプリのソース中に測定区間を指定して、
測定区間毎の統計情報をアプリ終了時・あるいは計算途中の指定位置で出力する。

数値計算性能を測定するためには該当区間の計算量を明示的な評価式の形で
PMlib APIへ引数として渡す。
測定区間は区間の名称、測定計算量の種類（演算量｜データ移動量）、
排他性（排他的｜非排他的）、蓄積計算量からなる少数の属性を持つ。
アプリ終了時の出力レポートに測定区間単位、プロセス単位、アプリ単位での
計算性能が表示される。
出力する情報の内容はアプリ実行時のオプションとして環境変数を指定する事によ
り制御される。
HWPC計算性能を測定する場合は計算量の種類・蓄積計算量はPMlib
内部で自動的に決定・積算されるため、PMlib APIへ引数として渡される値は
用いられない。

\subsection {PMlib APIの利用}
PMlibはC++およびFortranプログラムから呼び出して利用することができる。

以下の\lstlistingname \ref{listing1}はPMlib APIを利用するFortranソースプログラムの例である。

{ \color{blue} \par
lstlistingのcaptionは思い通りについてくれないので手を抜いてみるw \\
が、利用プログラム例はもう少しまともなコードの方が良いか、、、
} \par
%\begin{lstlisting}[caption={FortranプログラムへのPMlib組み込み例},label={listing1},captionpos=b]
\begin{lstlisting}[caption={\hfill},label={listing1},captionpos=t]
program main
call f_pm_initialize (nWatch)
call f_pm_setproperties ("Section1" icalc, iexcl)
call f_pm_start ("Section1")
call mykernel (fops)
call f_pm_stop ("Section1", fops, ncall)
call f_pm_print ("", isort)
call f_pm_printdetail ("", ilegend, isort)
end
\end{lstlisting}

数値計算上の計算性能を測定したい場合は、
PMlib APIの引数として該当区間の計算量を変数式で明示的に指定して積算する。
計算の種類ごとの「重たさ」を全て1.0と設定すると、ソースプログラムに
記述された計算式の全計算回数を数え上げる事に等しい。

HWPC測定値を基準とした（システム評価的観点での）計算性能を測定したい場合は、
該当区間のHWPCイベント統計情報をPMlibに自動的に読み取らせる。
HWPCの読み取りには内部でPAPI低レベルAPIを利用し、
選択と解釈が一般には容易ではない各種ハードウエアイベント統計情報を
カテゴリ分けしてアプリ利用者が評価しやすい情報として選択出力する。

{ \color{blue} \par
発表時のスライドでは橋本ツールと連携した組み込み手順のフローを紹介する。
\par }

PMlibではプロセス単位で性能情報を取得する設計となっていて、
プロセスがOpenMPスレッドを発生する場合、各スレッドの性能情報は帰属する
プロセスに集計される。

PMlibは一時的なベンチマークツールというよりは、アプリに常時組み込んで
プロダクション利用することを想定したライブラリである。

\subsection{PMlibの内部高性能タイマー}
PMlibは移殖が容易な汎用のパッケージであり、デフォルトではLinuxの標準タイマー
であるgettimeofday関数を利用するが、HPCシステムがオーバーヘッドの少ない
高解像度タイマーを有している場合や、タイムスタンプカウンタを直接
アクセスできる場合は、それを利用する事もできるパッケージングを目指している。
前節で示したHPCシステムでそのようなオプションを利用できる。
図\ref{fig:precise-timer} は標準タイマーを使用した場合と
高性能タイマーを使用した場合とのタイマー自身の測定解像度の比較である。

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/precise-timer.jpg}
\caption{precise-timer}
\label{fig:precise-timer}
\end{figure}



\subsection{PMlibの出力情報}
PMlibの出力として、標準出力や指定ファイルへのテキストレポート、および
汎用のトレースフォーマットであるOTF(Open Trace Format)ファイルを出力
する機能を持っている。


\subsection{関連する性能評価ツールと関連研究}

HPCシステム向けに様々な性能評価のためのツールが公開あるいは販売されている。\par
オープンソース性能評価ツール類としては
\begin{itemize}
	\item Gprof: 簡易機能、コンパイラに制約
	\item Scalasca \cite{Scalasca:2017} : トレース生成、Score-P共通インフラ
	\item Extrae \cite{Extrae:webpage} : トレース生成
	\item PAPI \cite{PAPI:5.6} : HWPCへのアクセス
	\item Linux perf tools : HWPCへのアクセス
\end{itemize}
ベンダーが提供する性能評価ツール類としてはX86系では 
\begin{itemize}
		\item Intel VTune \cite{Intel:VTune}, PGI Profiler \cite{PGI:Profiler}
\end{itemize}
また各HPCシステムは通常専用の性能評価ツールを装備している。
\begin{itemize}
	\item FX100システムでは富士通プロファイラなど
\end{itemize}
それぞれに特徴があり、
ベンダー製品のツールはパッケージが統合化されて完成度が高い反面、
利用できるシステムが制限され、相当の習熟期間が必要となる。
オープンソースのツールは様々なシステムへの移植が可能であるが、
各ツール毎に特徴・機能が明確で複数のツールを組み合わせて使う場合が多い。

特筆すべき点は、これら既存のツールはほぼ全てが評価の基準を、
システム評価的観点での性能すなわちHWPC測定性能に拠っていることである。


\section{PMlibを用いた性能測定と分析例}

\subsection{PMlibを用いた性能測定方法}

{ \color{blue} \par
PMlibでどのような分析ができるか \par
・HWPCベースでのアーキテクチャの有効利用状況 \par
・・使いやすい用にグループ化した統計出力 \par
・・SSE/AVX系命令の実行比率 \par
・・・ー＞SIMD機構の有効利用の確認 \par
・・キャッシュヒット率 \par
・・・ー＞コンパイラがどれだけ賢くコンピュータの能力を引き出しているか評価ができる \par
・・・ー＞コンパイラオプションの選択、指示行の指定などで、どのような効果が現れるか \par
・ピーク性能に対する実効性能比を裏付けてみる \par

発表スライドではCCA/EBT、OTF、HWPC(PAPI)を説明。そこに力点をおくとよい\\
Skylakeの例で示すといい\\
ルーフラインモデルを示し、実測との比較を見るとよい\\
} \par

性能測定には以下のプログラムを用いた
\begin{itemize}
\item{基本的な演算}
\item{STREAM}
\end{itemize}


\subsubsection{性能測定プラットフォーム}

測定には以下のHPCシステムを用いた。
\begin{itemize}
{
%	\setlength{\itemsep}{-5pt}
%	\setlength{\topsep}{2mm}
\item Intel Skylake CPU搭載サーバ
\item 富士通prime HPC FX100
}
\end{itemize}

これらプラットフォームの主にCPU部分についての性能諸元を
表\ref{tab:server-config}に示す。

%\tiny
%\footnotesize
%\small
\begin{table}[tb]
\scriptsize
\caption{サーバの構成と最大性能（主にCPU部分）}
\label{tab:server-config}
\footnotesize
\begin{tabular}{l|c|c} \hline
\scriptsize
system			&	FX100	&	Skylake	\\ \hline
CPU				&	SPARC64 VIIIifx	&	Gold 6148	\\ \hline
core GHz		&	1.975	&	2.4	\\ \hline
core Gflops	&	31.6	&	〜30	\\ \hline
L1\$ size (D,I)		&	64KB, 64KB	&	32KB, 32KB	\\ \hline
L1D\$ BW GB/s	&	140/R+70/W	&	154/R + 77/W	\\ \hline
\$ Linesize 	&	256B	&	64B	\\ \hline
L2\$ size		&	-	&	1MB	\\ \hline
L2\$ BW GB/s/core	&	-	&	154 ( ~70)	\\ \hline
LL\$ size		&	12MB	&	28MB(1.4MB/c)	\\ \hline
LL\$ BW GB/s/core	&	70/R+35/W	&	77 ( ~43)	\\ \hline
Memory			&	HMC(8x16Ls)	&	DDR4-2666	\\ \hline
Mem GB/s/[CMGcpu]	&	120/R+120/W	&	128	\\ \hline
\#cores/[CMGcpu]	&	16	&	20	\\ \hline
\end{tabular}
\end{table}


\subsubsection{基本的な演算性能の評価}

基本的な演算カーネル例として以下の様な、四則演算、平方根、３平方逆数
の配列計算を評価する。

基本的な演算カーネル例のソース：\lstlistingname \ref{listing2}

%	\begin{lstlisting}[label={listing2},captionpos=t]
\begin{lstlisting}[caption={\hfill},label={listing2},captionpos=t]
subroutine sub_add(a,b,c,n)
real*8 a(n), b(n), c(n)  
do i=1,n
c(i)=a(i)+b(i)
end do
return

subroutine sub_mult(a,b,c,n)
c(i)=a(i)*b(i) ! 計算式以外は同様

subroutine sub_fma(a,b,c,n)
c(i)=a(i)+b(i)*d ! 計算式以外は同様

subroutine sub_divide(a,b,c,n)
c(i)=b(i)/a(i) ! 計算式以外は同様

subroutine sub_sqrt(a,b,c,n)
c(i)=sqrt(a(i)) ! 計算式以外は同様

subroutine sub_mix(a,b,c,n)
c(i)=1.0/sqrt(a(i)**2+b(i)**2) ! 他同様

\end{lstlisting}

測定したHPCシステムのOSはjitter freeではないので、以下の方法により
測定時間のフィルタリングを行った。

ソース \lstlistingname \ref{listing2} の各
サブルーチンを1000回呼び出す中間ループ、およびその中間ループを
さらに10回反復する最外側ループを設ける。
\begin{itemize}
{
\item {各スレッドがサブルーチンを1000回呼び出す中間ループを実行し、
		その時間を測定する。}
\item {上の測定を10回繰り返して、標準偏差1σの範囲だけを採用する。}
\item {採用した測定値の平均値をスレッドの代表値とする}
\item {全スレッドの代表値の内、最小値をプロット用に採用}
}
\end{itemize}


この演算カーネルの測定をループ長
\begin{math}
n=1,2,4,..,2^{26}
\end{math}
に対してFX100で実行した結果を図 \ref{fig:fx100-gflops-long-R8}に示す。
表示しているのは数値計算上の性能である。
nの増加に連れてなだらかに性能が向上し、L1キャッシュ容量に収まる範囲で
最も高い性能に達し、その後L2キャッシュ容量の範囲内で、ついでメモリ
からのバンド幅で律速されるラインに落ち着くという全体傾向は、
従来の多数の関連研究結果と重なるものである。

{\color{blue} \par
これに関する参考論文はどれにする？
rooflineモデルと関連つけるのがよいか？
} \par

同じカーネルに対して
nを1から128の範囲で連続的に変化させて測定した結果を
図 \ref{fig:fx100-gflops-short-R8}に、
さらに1から50の範囲をクローズアップした結果を
図 \ref{fig:fx100-gflops-closeup-R8}に示す。

Perfが単調に増加するのではなく、nが４の倍数のタイミングで規則的に
向上する変動がみられ、
4n,4n+1,4n+2,4n+3と低下した後、4(n+1)で再び向上する。

この
図 \ref{fig:fx100-gflops-closeup-R8}に示す。
と同じ条件で実行したアプリのHWPC測定性能を表示すると
図 \ref{fig:fx100-HWPC-closeup-R8}の様になる。

{\color{blue} \par
今日まだ測定できていないので、とりあえず仮の図にしてある。
予想としては：4n,4n+1,4n+2,4n+3の性能がフラットになるだろうと思う。
差し替えた上で解釈を書く。

} \par

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/fx100-gflops-long-R8}
\caption{fx100-gflops-long-R8}
\label{fig:fx100-gflops-long-R8}
\end{figure}

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/fx100-gflops-short-R8}
\caption{fx100-gflops-short-R8}
\label{fig:fx100-gflops-short-R8}
\end{figure}

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/fx100-gflops-closeup-R8}
\caption{fig:fx100-gflops-closeup-R8}
\label{fig:fx100-gflops-closeup-R8}
\end{figure}

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/fx100-HWPC-closeup-R8}
\caption{fig:fx100-HWPC-closeup-R8}
\label{fig:fx100-HWPC-closeup-R8}
\end{figure}




\subsubsection{STREAM性能の評価}
STREAMベンチマーク\cite{stream:1995}
はコンピュータシステムのメモリバンド幅を測定するためのツールとして広く用いられている。
STREAMは変数配列の積和算（TRIAD）など、メモリread/write処理が主要な負荷となる
計算式の性能をアプリケーションプログラムレベルで測定出力する。
したがってその結果は「計算科学的観点」で評価された性能である。
このSTREAMプログラムを「システム評価的観点」で評価するとかなり様相が異なって来る。

まずSTREAMをSkylakeサーバ上で実行した場合の出力結果を示す。
Intelコンパイラのデフォルトオプションを用いている。
STREAM FortranプログラムOpenMPスレッド並列版を
1CPU上で8スレッド実行した場合、20スレッド実行した場合について示す。


Skylakeサーバ
されたHWPCベースでの
PMlibを用いて
メモリ階層での実測イベントベースによるデータ移動の状況を示す。
図



Intelコンパイラにはオプションが多数あり、中でも特にメモリバンド幅に関係が深いと
思われる以下のオプションを組み合わせて比較した結果を
図\ref{fig:stream-ivy-compact-1cpux8} に示す。\\
{\color{blue}この図は仮置きでIvybridgeの結果。Skylakeの結果と差し替えること。}

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/stream-ivy-compact-1cpux8.png}
\caption{stream-ivy-compact-1cpux8}
\label{fig:stream-ivy-compact-1cpux8}
\end{figure}


配列のファーストタッチなどデータの局所性確保、スレッドのコア固定など
を注意深く行うと、ノードに搭載された４CPUの全コアを使用した場合でも
同じような傾向の結果が得られる。
図\ref{fig:stream-ivy-scatter-4cpux8} に示す。\\

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/stream-ivy-scatter-4cpux8.png}
\caption{stream-ivy-scatter-4cpux8}
\label{fig:stream-ivy-scatter-4cpux8}
\end{figure}

これに対してアプリケーションのスレッド並列度が低い場合は様子が変わり、
例えばCPUあたり2スレッド（２コア）が実行されると
図\ref{fig:stream-ivy-scatter-4cpux2} の様になる。\\

\begin{figure}[tb]
\centering\includegraphics[width=0.45\textwidth]{figs/stream-ivy-scatter-4cpux2.png}
\caption{stream-ivy-scatter-4cpux2}
\label{fig:stream-ivy-scatter-4cpux2}
\end{figure}

図\ref{fig:stream-ivy-compact-1cpux8} と
図\ref{fig:stream-ivy-scatter-4cpux2} と
とでPMlibが出力するHWPC Cache関係の数値を比較すると＊＊＊
が読み取れる。


{ \color{blue} \par
note STREAM:Intel compilerでCache Eviction Levelオプションの指定効果はほとんど
なかった
} \par


\section{謝辞}
京補助金についての謝辞

%\cite{webpage2} \par
%\cite{webpage3} \par

\bibliographystyle{jplain}
\bibliography{main}
%\bibliography{bibsample}
\end{document}

